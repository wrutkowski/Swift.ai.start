---
title: Swift MVVM Architecture Guidelines
description: Guidelines for implementing the MVVM architecture pattern in SwiftUI applications with native navigation and hot reloading support
glob: "Sources/Modules/**/*.swift"
alwaysApply: true
---

@file ../Sources/Configuration/Configuration.swift
@file ../Sources/Modules/Home/HomeView.swift

# Swift MVVM Architecture Guidelines

## General Guidelines
1. Use the latest SwiftUI APIs and features whenever possible.
2. Implement `async/await` for asynchronous operations.
3. Write clean, readable, and well-structured code.
4. Follow the MVVM architecture to ensure modularity and scalability.
5. Use native SwiftUI navigation with `NavigationStack` and `NavigationLink`.

## Project Structure
All code should follow the established project structure:
- Base directory: SwiftCatalyst
- Main code in: Sources
- MVVM modules in: Sources/Modules/[ModuleName]/[ModuleName][ComponentType].swift

## File Naming Convention
- Module components should be named with the pattern [ModuleName][ComponentType].swift
- For example:
  - HomeView.swift
  - HomeViewModel.swift
  - HomeInteractor.swift
  - HomeEntity.swift

## Project Configuration

### Environment Variables
To make the project more configurable, use a `.env` file for environment-specific settings.

1. Create a `.env` file in the project root (add it to your `.gitignore`)
2. Use the `.env.example` file as a template for required variables
3. Run `./generate-project.sh` to create your project.yml from the template

The Configuration.swift file provides centralized access to all environment variables:

```swift
// Example usage:
let appName = Configuration.appName
let bundleId = Configuration.bundleIdPrefix + "." + Configuration.appName
```

This pattern allows for easy customization of:
- App name and bundle identifiers
- Team ID and app group ID
- API endpoints
- Feature flags
- Other environment-specific configuration

## MVVM Architecture Overview
Each module in your SwiftUI app should follow the MVVM structure:

### 1. **View**
   - The SwiftUI `View` handles user interface (UI) rendering and user interactions.
   - Import the `Inject` framework to enable hot reloading.
   - Use `@ObserveInjection` to monitor changes for hot reloading.
   - Use the `.enableInjection()` modifier in the view body.
   - Use `@ObservedObject` to observe the ViewModel.
   - Use native SwiftUI `NavigationStack` for navigation.

   ```swift
   import SwiftUI
   import Inject

   struct YourViewName: View {
       @ObserveInjection var injected
       @ObservedObject var viewModel: YourViewModel

       var body: some View {
           NavigationStack {
               VStack {
                   // UI elements here
               }
               .navigationDestination(for: YourItem.self) { item in
                   YourDetailView(item: item)
               }
           }
           .enableInjection()
       }
   }
   ```

### 2. **ViewModel**
   - The `ViewModel` manages the view's state and business logic.
   - Use `@Published` properties to expose state to the View.
   - Use protocols to define the interaction between the ViewModel and Interactor.
   - Mark state-changing methods with `@MainActor` to ensure UI updates on the main thread.

   ```swift
   protocol YourViewModelProtocol: ObservableObject {
       var data: [YourEntity] { get }
       func loadData() async
   }

   final class YourViewModel: YourViewModelProtocol {
       @Published private(set) var data: [YourEntity] = []
       @Published private(set) var isLoading: Bool = false
       @Published private(set) var errorMessage: String?

       private let interactor: YourInteractorProtocol

       init(interactor: YourInteractorProtocol) {
           self.interactor = interactor
       }

       @MainActor
       func loadData() async {
           isLoading = true
           defer { isLoading = false }
           errorMessage = nil
           do {
               data = try await interactor.fetchData()
           } catch {
               errorMessage = "Failed to load data: \(error.localizedDescription)"
           }
       }
   }
   ```

### 3. **Interactor**
   - The `Interactor` handles data layer logic and communicates with external sources (APIs, databases, etc.).
   - Use protocols to define the interaction between the ViewModel and Interactor.

   ```swift
   protocol YourInteractorProtocol {
       func fetchData() async throws -> [YourEntity]
   }

   final class YourInteractor: YourInteractorProtocol {
       func fetchData() async throws -> [YourEntity] {
           // Fetch or compute data
       }
   }
   ```

### 4. **Entity**
   - Define simple data models used by the ViewModel and Interactor.
   - Make entities `Hashable` when using them for navigation with `NavigationStack`.

   ```swift
   struct YourEntity: Identifiable, Hashable {
       let id: UUID
       let name: String
   }
   ```

### 5. **Navigation**
   - Use native SwiftUI `NavigationStack` instead of a Router.
   - Use `NavigationLink` with `navigationDestination` for declarative navigation.
   - Entities used for navigation must be `Hashable`.

   ```swift
   NavigationStack {
       List(viewModel.items) { item in
           NavigationLink(value: item) {
               Text(item.name)
           }
       }
       .navigationDestination(for: YourEntity.self) { item in
           YourDetailView(item: item)
       }
   }
   ```

## Hot Reloading Setup
To enable hot reloading in all SwiftUI views:
1. **Import the Inject framework** in the `View`.
2. **Add the `@ObserveInjection` property wrapper**.
3. **Use the `.enableInjection()` modifier** in the main body of the view.

Example:
```swift
import SwiftUI
import Inject

struct ExampleView: View {
    @ObserveInjection var injected
    var body: some View {
        Text("Hello, MVVM!")
            .enableInjection()
    }
}
```

## State Management
1. Use `@Published` properties in the `ViewModel` to manage and update state.
2. Avoid using `@State` or `@StateObject` directly in the `View`. Instead, rely on the `ViewModel` for state via `@ObservedObject`.
3. Pass dependencies via initializers to ensure clear and testable code.
4. Use `@MainActor` on ViewModel methods that update state to ensure thread safety.

## Performance Optimization
1. Use `LazyVStack`, `LazyHStack`, or `LazyVGrid` for large lists or grids to improve performance.
2. Optimize `ForEach` loops by providing stable and unique identifiers.
3. Use `NavigationStack` instead of deprecated `NavigationView` for better performance.

## Reusable Components
1. Implement custom view modifiers for shared styling and behavior.
2. Use extensions to add reusable functionality to existing types.

## Accessibility
1. Add accessibility modifiers to all UI elements.
2. Support Dynamic Type for text scaling.
3. Provide clear accessibility labels and hints.

## SwiftUI Lifecycle
1. Use the `App` protocol and `@main` for the app entry point.
2. Implement `Scene` for managing app structure.
3. Use appropriate lifecycle methods like `onAppear` and `onDisappear`.

## Data Flow
1. Use protocols to define communication between MVVM components.
2. Implement proper error handling and data propagation in the `Interactor`.
3. View → ViewModel: User actions call ViewModel methods
4. ViewModel → Interactor: ViewModel calls Interactor for data
5. Interactor → ViewModel: Data flows back through async/await
6. ViewModel → View: `@Published` properties trigger UI updates

## Testing
1. Write unit tests for `Interactor` and `ViewModel` logic.
2. Use mock implementations of Interactor in ViewModel tests.
3. Implement UI tests for critical user flows.
4. Use `PreviewProvider` for rapid UI iteration and visual validation.
5. Test files should mirror the module structure: `Tests/Modules/[ModuleName]/[ComponentName]Tests.swift`

## SwiftUI-specific Patterns
1. Use `@Binding` for two-way data flow when needed.
2. Implement custom `PreferenceKey` for child-to-parent communication.
3. Utilize `@Environment` for dependencies shared across multiple views.
4. Use `NavigationStack` with `NavigationLink` for type-safe navigation.

## Navigation Best Practices
1. Always use `NavigationStack` for iOS 16+.
2. Make navigation entities `Hashable` and `Identifiable`.
3. Use `navigationDestination` for declarative navigation.
4. Keep navigation logic in the view, not in a separate Router.
5. Use `NavigationLink(value:)` for programmatic navigation.

## Code Style and Formatting
1. Follow Swift naming conventions and style guidelines.
2. Use tools like SwiftLint to enforce consistent code style.

## XcodeGen Configuration
1. Use XcodeGen for project generation to avoid merge conflicts.
2. Include the Inject framework as a Swift Package dependency.
3. Add the required linker flags (`-Xlinker -interposable`) for hot reloading.

## Cursor IDE Setup
1. Generate Build Server Config using Sweetpad extension.
2. Use Sweetpad for building and debugging.
3. Ensure project.yml is properly configured for hot reloading.
